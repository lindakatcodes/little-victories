---
import StarFilled from "@icons/star-filled.svg";
import { type RewardPicture, type Task, Numbers } from "@utils/types.ts";
import { actions } from "astro:actions";
import Button from "./Button.astro";
import RewardImage from "./RewardImage";
import TaskCard from "./TaskCard";

// get the user's current journey
const userId = Astro.cookies.get("userId")!.value;
const { data, error } = await Astro.callAction(actions.getActiveJourney, {
  id: userId,
});
if (error) console.log({ error });

// splitting tasks and rewards into their own variables so we can enforce the schema
const tasks = data?.taskList as Task[];
const reward = data?.rewardPic as RewardPicture;

// this task is a prereq for a few others, so when the page loads we want to check it's status to pass along to the task cards
const findJobTask = tasks.find(
  (task) => task.taskAction.task === "Find a job to apply for"
);
const findJobTaskDone = findJobTask ? findJobTask.taskComplete : false;

// to start a new journey we need to pass the current journey's id and the user id - but we need to convert it from an object to a string so we can parse it properly on the other side
const newJourneyVars = JSON.stringify({
  currentJourney: data?.id,
  userId,
});

// these need to live here since we have access to the env variables securely on the server
const rewardCredit = `${reward.creditUrl}/?${
  import.meta.env.UNSPLASH_REFERRER
}`;
const rewardSource = `https://unsplash.com/?${
  import.meta.env.UNSPLASH_REFERRER
}`;
---

<section>
  <div class="reward">
    <RewardImage
      image={reward}
      imageCredit={rewardCredit}
      imageSrc={rewardSource}
      initialTasksCompleted={data?.tasksCompleted || 0}
      client:load
    />
  </div>

  <div class="completed">
    <Button
      text="Start a new Journey!"
      action="setNewJourney"
      actionVars={newJourneyVars}
    />
  </div>

  <div class="path-wrapper">
    <canvas class="path-canvas"></canvas>
    <div class="path-tiles">
      {
        tasks.map((task) => (
          <div class:list={[`tile ${Numbers[task.taskId]}`]}>
            <TaskCard
              task={task}
              journeyId={data!.id}
              findJobPrereq={findJobTaskDone}
              client:visible
            >
              <StarFilled />
            </TaskCard>
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  section {
    container: inline-size;
    inline-size: 80cqw;
    margin: 0 auto;

    @media (width >= 48rem) {
      & {
        inline-size: 75cqw;
      }
    }

    @media (width >= 64rem) {
      & {
        inline-size: 65cqw;
      }
    }

    @media (width >= 80rem) {
      & {
        inline-size: 55cqw;
      }
    }

    @media (width >= 96rem) {
      & {
        inline-size: 40cqw;
      }
    }
  }

  .reward {
    inline-size: 80cqw;
    margin: 0 auto;

    @media (width >= 48rem) {
      & {
        inline-size: 60cqw;
      }
    }

    @media (width >= 80rem) {
      & {
        inline-size: 50cqw;
      }
    }
  }

  .completed {
    margin: 2rem auto;
    block-size: 2.875rem;
    display: grid;
    justify-items: center;
    visibility: hidden;
    opacity: 0;
  }

  .path-wrapper {
    inline-size: 80cqw;
    margin: 0 auto 2rem;
    display: grid;

    @media (width >= 48rem) {
      & {
        inline-size: 60cqw;
      }
    }

    @media (width >= 80rem) {
      & {
        inline-size: 50cqw;
      }
    }
  }

  .path-canvas {
    grid-area: 1 / 1;
    inline-size: 100%;
    block-size: 100%;
    z-index: -1;
  }

  .path-tiles {
    grid-area: 1 / 1;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(15, 6rem);
    place-items: center;
    row-gap: 1.25rem;
  }

  .tile {
    inline-size: 7rem;
    block-size: 6rem;
    border: 2px solid var(--dark-blue);
    border-radius: 0.25rem;
    background: var(--light-blue);
  }

  .one {
    grid-column: 1 / span 2;
    grid-row: 15;
  }

  .two {
    grid-column: 2 / span 2;
    grid-row: 14;
  }

  .three {
    grid-column: 3 / span 2;
    grid-row: 13;
  }

  .four {
    grid-column: 4 / span 2;
    grid-row: 12;
  }

  .five {
    grid-column: 3 / span 2;
    grid-row: 11;
  }

  .six {
    grid-column: 2 / span 2;
    grid-row: 10;
  }

  .seven {
    grid-column: 1 / span 2;
    grid-row: 9;
  }

  .eight {
    grid-column: 2 / span 2;
    grid-row: 8;
  }

  .nine {
    grid-column: 3 / span 2;
    grid-row: 7;
  }

  .ten {
    grid-column: 4 / span 2;
    grid-row: 6;
  }

  .eleven {
    grid-column: 3 / span 2;
    grid-row: 5;
  }

  .twelve {
    grid-column: 2 / span 2;
    grid-row: 4;
  }

  .thirteen {
    grid-column: 1 / span 2;
    grid-row: 3;
  }

  .fourteen {
    grid-column: 2 / span 2;
    grid-row: 2;
  }

  .fifteen {
    grid-column: 3 / span 2;
    grid-row: 1;
  }
</style>

<script>
  // thanks Claude - creates the lines to connect all the tiles together
  function drawPath() {
    const canvas = document.querySelector(".path-canvas") as HTMLCanvasElement;
    const path = document.querySelector(".path-tiles") as HTMLElement;
    const tiles = Array.from(document.querySelectorAll(".tile"));

    if (!canvas || !path) return;

    // Match canvas size to path container
    canvas.width = path.offsetWidth;
    canvas.height = path.offsetHeight;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    ctx.strokeStyle = "var(--dark-blue)";
    ctx.lineWidth = 1;
    ctx.beginPath();

    // Connect tiles in sequence
    tiles.reverse().forEach((tile, i) => {
      const rect = tile.getBoundingClientRect();
      const pathRect = path.getBoundingClientRect();

      // Convert to canvas coordinates
      const x = rect.left - pathRect.left + rect.width / 2;
      const y = rect.top - pathRect.top + rect.height / 2;

      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();
  }

  drawPath();

  window.addEventListener("resize", drawPath);
</script>

<script>
  // toggle the "start a new journey" button based on number of completed tasks
  import { totalTasksCompleted } from "@stores/taskStore";

  const completedBtn: HTMLDivElement = document.querySelector(
    ".completed"
  ) as HTMLDivElement;
  totalTasksCompleted.subscribe((count) => {
    if (count === 15) {
      setTimeout(() => {
        completedBtn!.style.visibility = "visible";
        completedBtn!.style.opacity = "1";
        completedBtn!.style.transition = "opacity 1s ease-out";
      }, 500);
    }
  });
</script>
