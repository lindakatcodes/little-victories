---
import { actions } from "astro:actions";
import { type Task, type RewardPicture, Numbers } from "@utils/types.ts";
import RewardImage from "./RewardImage.astro";

const userId = Astro.cookies.get("userId")!.value;
const { data, error } = await Astro.callAction(actions.getActiveJourney, {
  id: userId,
});
if (error) console.log({ error });
const tasks = data?.taskList as Task[];
const reward = data?.rewardPic as RewardPicture;
const currentTask = data?.currentTask;
---

<section>
  <div class="reward">
    {
      data?.tasksCompleted === 15 ? (
        <RewardImage isLocked={false} image={reward} />
      ) : (
        <RewardImage isLocked={true} image={reward} />
      )
    }
  </div>

  <div class="path-wrapper">
    <canvas class="path-canvas"></canvas>
    <div class="path">
      {
        tasks.map((task) => (
          <div
            class:list={[
              `tile ${Numbers[task.taskId]}`,
              { isActive: currentTask === task.taskId },
            ]}
          >
            {task.taskId}
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  section {
    container: inline-size;
    inline-size: 80cqw;
    margin: 0 auto;

    @media (width >= 48rem) {
      & {
        inline-size: 75cqw;
      }
    }

    @media (width >= 64rem) {
      & {
        inline-size: 65cqw;
      }
    }

    @media (width >= 80rem) {
      & {
        inline-size: 55cqw;
      }
    }

    @media (width >= 96rem) {
      & {
        inline-size: 40cqw;
      }
    }
  }

  .reward {
    inline-size: 100%;
    margin: 0 auto;

    @media (width >= 48rem) {
      & {
        inline-size: 70%;
      }
    }
  }

  .path-wrapper {
    inline-size: 100%;
    margin: 0 auto 2rem;
    display: grid;

    @media (width >= 48rem) {
      & {
        inline-size: 70%;
      }
    }
  }

  .path-canvas {
    grid-area: 1 / 1;
    inline-size: 100%;
    block-size: 100%;
  }

  .path {
    grid-area: 1 / 1;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(15, 3.5rem);
    place-items: center;
  }

  .tile {
    inline-size: 2.5rem;
    block-size: 2.5rem;
    border: 2px solid var(--dark-blue);
    border-radius: 0.25rem;
    display: grid;
    place-items: center;
    background: var(--dark-blue);
    color: var(--light-blue);
  }

  .isActive {
    background: var(--light-blue);
    color: var(--dark-blue);
  }

  .one {
    grid-column: 1;
    grid-row: 15;
  }

  .two {
    grid-column: 2;
    grid-row: 14;
  }

  .three {
    grid-column: 3;
    grid-row: 13;
  }

  .four {
    grid-column: 4;
    grid-row: 12;
  }

  .five {
    grid-column: 5;
    grid-row: 11;
  }

  .six {
    grid-column: 4;
    grid-row: 10;
  }

  .seven {
    grid-column: 3;
    grid-row: 9;
  }

  .eight {
    grid-column: 2;
    grid-row: 8;
  }

  .nine {
    grid-column: 1;
    grid-row: 7;
  }

  .ten {
    grid-column: 2;
    grid-row: 6;
  }

  .eleven {
    grid-column: 3;
    grid-row: 5;
  }

  .twelve {
    grid-column: 4;
    grid-row: 4;
  }

  .thirteen {
    grid-column: 5;
    grid-row: 3;
  }

  .fourteen {
    grid-column: 4;
    grid-row: 2;
  }

  .fifteen {
    grid-column: 3;
    grid-row: 1;
  }
</style>

<script>
  // thanks Claude - creates the lines to connect all the tiles together
  function drawPath() {
    const canvas = document.querySelector(".path-canvas") as HTMLCanvasElement;
    const path = document.querySelector(".path") as HTMLElement;
    const tiles = Array.from(document.querySelectorAll(".tile"));

    if (!canvas || !path) return;

    // Match canvas size to path container
    canvas.width = path.offsetWidth;
    canvas.height = path.offsetHeight;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    ctx.strokeStyle = "var(--dark-blue)";
    ctx.lineWidth = 1;
    ctx.beginPath();

    // Connect tiles in sequence
    tiles.reverse().forEach((tile, i) => {
      const rect = tile.getBoundingClientRect();
      const pathRect = path.getBoundingClientRect();

      // Convert to canvas coordinates
      const x = rect.left - pathRect.left + rect.width / 2;
      const y = rect.top - pathRect.top + rect.height / 2;

      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();
  }

  drawPath();

  window.addEventListener("resize", drawPath);

  // the journey builds up, so we want to scroll the user to their current task once it loads in
  const currentTask = document.querySelector(".isActive");
  setTimeout(() => {
    currentTask?.scrollIntoView({
      behavior: "smooth",
      block: "end",
      inline: "nearest",
    });
  }, 2500);
</script>
